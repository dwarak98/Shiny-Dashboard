future = forecast(x,h=5)
View(future)
future$fitted
plot(forecast(x,h=5))
library(forecast)
df <- read.csv("dalmp.csv",header = TRUE)
df = subset(df, select = c(OPERATION_DATE,PRICE))
df <- aggregate(df$PRICE,by=list(OPERATION_DATE = df$OPERATION_DATE),FUN = mean)
x <- auto.arima(df$x)
plot(forecast(x,h=5))
plot(df$x)
ARIMA <- function(df,y,p,q,d)
{
}
library(forecast)
df <- read.csv("dalmp.csv",header = TRUE)
df = subset(df, select = c(OPERATION_DATE,PRICE))
df <- aggregate(df$PRICE,by=list(OPERATION_DATE = df$OPERATION_DATE),FUN = mean)
x <- auto.arima(df$x)
plot(forecast(x,h=5))
ARIMA <- function(df,y,p,q,d)
{
}
plot(df$OPERATION_DATE,forecast(x,h=5))
library(forecast)
df <- read.csv("dalmp.csv",header = TRUE)
df = subset(df, select = c(OPERATION_DATE,PRICE))
df <- aggregate(df$PRICE,by=list(OPERATION_DATE = df$OPERATION_DATE),FUN = mean)
x <- auto.arima(df$x)
plot(df$OPERATION_DATE,forecast(x,h=0))
ARIMA <- function(df,y,p,q,d)
{
}
library(forecast)
df <- read.csv("dalmp.csv",header = TRUE)
df = subset(df, select = c(OPERATION_DATE,PRICE))
df <- aggregate(df$PRICE,by=list(OPERATION_DATE = df$OPERATION_DATE),FUN = mean)
x <- auto.arima(df$x)
plot(df$OPERATION_DATE,df$x)
ARIMA <- function(df,y,p,q,d)
{
}
library(forecast)
df <- read.csv("dalmp.csv",header = TRUE)
df = subset(df, select = c(OPERATION_DATE,PRICE))
df <- aggregate(df$PRICE,by=list(OPERATION_DATE = df$OPERATION_DATE),FUN = mean)
x <- auto.arima(df$x)
plot(forecast(x,h=10))
ARIMA <- function(df,y,p,q,d)
{
}
View(future)
library(forecast)
df <- read.csv("dalmp.csv",header = TRUE)
df = subset(df, select = c(OPERATION_DATE,PRICE))
df <- aggregate(df$PRICE,by=list(OPERATION_DATE = df$OPERATION_DATE),FUN = mean)
x <- auto.arima(df$x)
plot(forecast(x,h=3))
ARIMA <- function(df,y,p,q,d)
{
}
View(future)
length(df$x)
library(forecast)
df <- read.csv("dalmp.csv",header = TRUE)
df = subset(df, select = c(OPERATION_DATE,PRICE))
df <- aggregate(df$PRICE,by=list(OPERATION_DATE = df$OPERATION_DATE),FUN = mean)
length(df$x)
x <- auto.arima(df$x)
future <- forecast(x,h=3)
length(future$fitted)
ARIMA <- function(df,y,p,q,d)
{
}
View(future)
future$mean
future$upper
library(forecast)
df <- read.csv("dalmp.csv",header = TRUE)
df = subset(df, select = c(OPERATION_DATE,PRICE))
df <- aggregate(df$PRICE,by=list(OPERATION_DATE = df$OPERATION_DATE),FUN = mean)
length(df$x)
x <- auto.arima(df$x)
future <- forecast(x,h=10)
length(future$fitted)
ARIMA <- function(df,y,p,q,d)
{
}
library(forecast)
df <- read.csv("dalmp.csv",header = TRUE)
df = subset(df, select = c(OPERATION_DATE,PRICE))
df <- aggregate(df$PRICE,by=list(OPERATION_DATE = df$OPERATION_DATE),FUN = mean)
length(df$x)
x <- auto.arima(df$x)
future <- forecast(x,h=10)
length(future$fitted)
future$mean
ARIMA <- function(df,y,p,q,d)
{
}
library(forecast)
df <- read.csv("dalmp.csv",header = TRUE)
df = subset(df, select = c(OPERATION_DATE,PRICE))
df <- aggregate(df$PRICE,by=list(OPERATION_DATE = df$OPERATION_DATE),FUN = mean)
length(df$x)
x <- auto.arima(df$x)
future <- forecast(x,h=10)
length(future$fitted)
future$upper
ARIMA <- function(df,y,p,q,d)
{
}
View(future)
library(shiny); runApp('dashboard.R')
runApp('dashboard.R')
install.packages(c("bookdown", "choroplethr", "choroplethrMaps", "data.table", "datasets", "devtools", "dlnm", "dplyr", "faraway", "forcats", "GGally", "ggmap", "ggplot2", "ggthemes", "ghit", "GISTools", "grid", "gridExtra", "httr", "knitr", "leaflet", "lubridate", "magrittr", "methods", "microbenchmark", "package", "pander", "plotly", "profvis", "pryr", "purrr", "rappdirs", "raster", "RColorBrewer", "readr", "rmarkdown", "scales", "sp", "stats", "stringr", "testthat", "tidyr", "tidyverse", "tigris", "titanic", "viridis"))
install.packages(c("bookdown", "choroplethr", "choroplethrMaps", "data.table", "datasets", "devtools", "dlnm", "dplyr", "faraway", "forcats", "GGally", "ggmap", "ggplot2", "ggthemes", "ghit", "GISTools", "grid", "gridExtra", "httr", "knitr", "leaflet", "lubridate", "magrittr", "methods", "microbenchmark", "package", "pander", "plotly", "profvis", "pryr", "purrr", "rappdirs", "raster", "RColorBrewer", "readr", "rmarkdown", "scales", "sp", "stats", "stringr", "testthat", "tidyr", "tidyverse", "tigris", "titanic", "viridis"))
install.packages(c("bookdown", "choroplethr", "choroplethrMaps", "data.table", "datasets", "devtools", "dlnm", "dplyr", "faraway", "forcats", "GGally", "ggmap", "ggplot2", "ggthemes", "ghit", "GISTools", "grid", "gridExtra", "httr", "knitr", "leaflet", "lubridate", "magrittr", "methods", "microbenchmark", "package", "pander", "plotly", "profvis", "pryr", "purrr", "rappdirs", "raster", "RColorBrewer", "readr", "rmarkdown", "scales", "sp", "stats", "stringr", "testthat", "tidyr", "tidyverse", "tigris", "titanic", "viridis"))
install.packages(c("bookdown", "choroplethr", "choroplethrMaps", "data.table", "datasets", "devtools", "dlnm", "dplyr", "faraway", "forcats", "GGally", "ggmap", "ggplot2", "ggthemes", "ghit", "GISTools", "grid", "gridExtra", "httr", "knitr", "leaflet", "lubridate", "magrittr", "methods", "microbenchmark", "package", "pander", "plotly", "profvis", "pryr", "purrr", "rappdirs", "raster", "RColorBrewer", "readr", "rmarkdown", "scales", "sp", "stats", "stringr", "testthat", "tidyr", "tidyverse", "tigris", "titanic", "viridis"))
library(shiny); runApp('dashboard.R')
getForecastVsActual <- function() {
myfile <-
getURL(
'https://marketplace.spp.org/chart-api/load-forecast/asFile',
ssl.verifyhost = FALSE,
ssl.verifypeer = FALSE
)
df <- read.csv(textConnection(myfile), header = T)
df <- format_DateTime(df, "Interval", "mdy_hms")
df$wind_pen_actual <- df$Actual.Wind * 100 / df$Actual.Load
df$wind_pen_STF <- df$STWF * 100 / df$STLF
df$wind_pen_MTF <- df$MTWF * 100 / df$MTLF
setDT(df)
df <- melt(df, id = c("Interval", "Hour", "GMTIntervalEnd"))
return(df)
}
runApp('dashboard.R')
runApp('dashboard.R')
runApp('dashboard.R')
runApp('dashboard.R')
library(shinydashboard)
library(shiny)
library(stringr)
library(dplyr)
library(ggplot2)
library(tidyverse)
library(lubridate)
library(plotly)
library(data.table)
library(lubridate)
library(RCurl)
require(plotly)
library(tidyr)
library(ggplot2)
library(forecast)
library(tseries)
library(sjmisc)
source("backEnd.R")
df = getForecastVsActual()
library(shinydashboard)
library(shiny)
library(stringr)
library(dplyr)
library(ggplot2)
library(tidyverse)
library(lubridate)
library(plotly)
library(data.table)
library(lubridate)
library(RCurl)
require(plotly)
library(tidyr)
library('ggplot2')
library('forecast')
library('tseries')
# source("frontEnd.R")
###################### Date Time Formatting #########################################
format_DateTime <- function(df, dateColName, format) {
df[[dateColName]] = str_replace_all(df[[dateColName]], "/", "-")
if (format == "ymd_hms") {
df[[dateColName]] <-
ymd_hms(df[[dateColName]], tz = Sys.timezone())
}
else if (format == "mdy_hms") {
df[[dateColName]] <- mdy_hms(df[[dateColName]], tz = Sys.timezone())
}
df$Hour <- hour(df[[dateColName]])
return(df)
}
################################# Downloading VER data #########################################
getForecastVsActual <- function() {
myfile <-
getURL(
'https://marketplace.spp.org/chart-api/load-forecast/asFile',
ssl.verifyhost = FALSE,
ssl.verifypeer = FALSE
)
df <- read.csv(textConnection(myfile), header = T)
df <- format_DateTime(df, "Interval", "mdy_hms")
df$wind_pen_actual <- df$Actual.Wind * 100 / df$Actual.Load
df$wind_pen_STF <- df$STWF * 100 / df$STLF
df$wind_pen_MTF <- df$MTWF * 100 / df$MTLF
setDT(df)
df <- melt(df, id = c("Interval", "Hour", "GMTIntervalEnd"))
return(df)
}
combine_df_Columns <- function(df, resultColName, colNames) {
i = 0
for (colName in colNames) {
if (i == 0) {
df[[resultColName]] <- df[[colName]]
}
else{
df[[resultColName]] <- df[[resultColName]] + df[[colName]]
}
i = i + 1
}
return(df)
}
################################# Downloading Generation Data from spp Portal #########################################
getGenMix <- function() {
myfile     <-
getURL(
'https://marketplace.spp.org/chart-api/gen-mix-dl/asFile',
ssl.verifyhost = FALSE,
ssl.verifypeer = FALSE
)
gendf      <- read.csv(textConnection(myfile), header = T)
gendf <- format_DateTime(gendf, "GMT.MKT.Interval", "ymd_hms")
gendf <- gendf %>%
combine_df_Columns("Coal", c("Coal.Market", "Coal.Self")) %>%
combine_df_Columns("Nuclear", c("Nuclear.Market", "Nuclear.Self")) %>%
combine_df_Columns("oil", c("Diesel.Fuel.Oil.Market", "Diesel.Fuel.Oil.Self")) %>%
combine_df_Columns("Hydro", c("Hydro.Market", "Hydro.Self")) %>%
combine_df_Columns("Natural_Gas", c("Natural.Gas.Market", "Natural.Gas.Self")) %>%
combine_df_Columns("Solar", c("Solar.Market", "Solar.Self")) %>%
combine_df_Columns(
"Waste_Disposal",
c(
"Waste.Disposal.Services.Market",
"Waste.Disposal.Services.Self"
)
) %>%
combine_df_Columns("Wind", c("Wind.Market", "Wind.Self")) %>%
combine_df_Columns("Others", c("Other.Market", "Other.Self")) %>%
select(-ends_with(".Market")) %>%
select(-ends_with(".Self")) %>%
setDT() %>%
melt(id = c("GMT.MKT.Interval", "Hour")) %>%
arrange(desc(GMT.MKT.Interval))
# print(head(gendf,length(unique(gendf$variable))))
return(head(gendf, length(unique(gendf$variable))))
}
df = getForecastVsActual()
gendf = getGenMix()
server <- function(input, output, session) {
########### RT Update of SPP operational Data ####################
sourceData <- reactive({
invalidateLater(60000, session)
# functionThatGetsData()
getForecastVsActual()
})
gensourceData <- reactive({
invalidateLater(60000, session)
# functionThatGetsData()
getGenMix()
})
VER_data_r1 <- reactive({
dplyr::filter(
sourceData(),
between(as_date(df$Interval), input$date[1], input$date[2]) &
df$variable %in% input$select_input
)
})
VER_data_r2 <- reactive({
dplyr::filter(VER_data_r1(),
between(Hour, input$slider_input[1], input$slider_input[2]))
})
############# Static Line Chart #################################
output$line <- renderPlotly({
p1 <-
ggplot(VER_data_r2(),
aes(
x = Interval,
y = value,
col = variable,
text = paste(
"</br>Date: ",
Interval,
"</br>Value: ",
value,
"</br>Category: ",
variable
)
)) + geom_point() + geom_line() + theme_minimal() + labs(y = "Wind Penetration (%)", x = "Datetime", col = "Category")
ggplotly(p1, tooltip = c("text"))
})
############# Static Bar Chart #################################
output$bar <- renderPlotly({
p1 <-
ggplot(gensourceData(),
aes(
x = variable,
y = value,
fill = variable,
text = paste("</br>Resource: ", variable, "</br>Energy (MWh): ", value)
)) +
geom_bar(position = "dodge", stat = "identity")
p2 <-
p1 + theme_classic() + labs(y = "Energy (MWh)", x = "Resources", fill = "Resources") +
theme_minimal()
ggplotly(p2, tooltip = c("text"))
})
################ Visualization #########################
############ Read the imported csv file ######################
data <- reactive({
req(input$file1)
inFile <- input$file1
print(inFile$datapath)
read.csv(inFile$datapath, header = TRUE)
})
########## Displays top 5 rows of the imported csv #############
output$head <- renderTable({
head(data(), input$n)
})
########### Display Line Plot #################
data1 <- reactive({
req(input$file1)
inFile <- input$file1
print(inFile$datapath)
read.csv(inFile$datapath, header = TRUE)
})
output$lineplotVar1 <- renderUI({
if (input$charttype == "Line")
{
choices <- unique(colnames(data()))
selectInput("xaxis",
"X_Axis",
choices = choices,
multiple = TRUE)
}
})
output$lineplotVar2 <- renderUI({
if (input$charttype == "Line")
{
choices <- unique(colnames(data()))
selectInput("yaxis",
"Y_Axis",
choices = choices,
multiple = TRUE)
}
})
output$lineplotVar3 <- renderUI({
if (input$charttype == "Line")
{
choices <- unique(colnames(data()))
selectInput("category",
"Category",
choices = choices,
multiple = TRUE)
}
})
output$LinePlot <- renderUI({
if (input$charttype == "Line")
{
plotlyOutput(outputId = "dline", height = 400)
}
})
output$dline <- renderPlotly({
{
data2 <- data1()
print(data2)
data2 <- data2 %>% rename(
col1 = input$xaxis,
col2 = input$yaxis,
category = input$category
)
p1 <-
ggplot(data2, aes(
x = col1,
y = col2,
fill = category,
text = paste(
"</br>X-axis: ",
col1,
"</br>Y-Axis: ",
col2,
"</br>Category: ",
category
)
)) + geom_col() + theme_minimal() + labs(y = input$yaxis,
x = input$xaxis,
col = input$category)
ggplotly(p1, tooltip = c("text"))
}
})
####################### Table Display ###################
output$tablecol1 <- renderUI({
if (input$charttype == "Table")
{
choices <- unique(colnames(data()))
selectInput("VALUE",
"ENTER THE AMOUNT OR VALUE",
choices = choices,
multiple = TRUE)
}
})
output$tablecol2 <- renderUI({
if (input$charttype == "Table")
{
choices <- unique(colnames(data()))
selectInput("Row",
"List of Row",
choices = choices,
multiple = TRUE)
}
})
output$tablecol3 <- renderUI({
if (input$charttype == "Table")
{
choices <- unique(colnames(data()))
selectInput("Column",
"List of Columns",
choices = choices,
multiple = TRUE)
}
})
output$tableplot <- renderUI({
if (input$charttype == "Table")
{
DT::dataTableOutput(outputId = "table")
}
})
new_data <- reactive({
print(input$Column[2])
if (is.na(input$Column[2]))
{
newdata1 <- data1() %>% rename(
Col1 = input$Column[1],
Vue = input$VALUE,
Rws = input$Row
)
newdata1 %>% group_by(Col1) %>% summarise(Value = sum(as.numeric(Vue)))
# aggregate(newdata1$input$VALUE, by=list(newdata1$input$Column), FUN=sum)
}
else if (!is.na(input$Column[2]))
{
newdata1 <- data1() %>% rename(
Col1 = input$Column[1],
Col2 = input$Column[2],
Vue = input$VALUE,
Rws = input$Row
)
newdata1 %>% group_by(Col1,Col2) %>% summarise(Value = sum(as.numeric(Vue)))
# aggregate(newdata1$input$VALUE, by=list(newdata1$input$Column), FUN=sum)
}
})
output$table <- DT::renderDataTable({
new_data()
#,options = list(pageLength = 5,initComplete = I("function(settings, json) {alert('Done.');}"))
})
##################### PREDICTION #########################
output$y_variable <- renderUI({
if (input$algo == "ARIMA")
{
choices <- unique(colnames(data()))
selectInput("y_variable1",
"What to Predict",
choices = choices,
multiple = TRUE)
}
})
output$y_variable <- renderUI({
if (input$algo == "ARIMA")
{
choices <- unique(colnames(data()))
selectInput("y_variable1",
"What to Predict",
choices = choices,
multiple = TRUE)
}
})
output$P <- renderUI({
if (input$algo == "ARIMA")
{
numericInput("P1",
h3("Auto Regressive Coeffcienct (P)"),
value = 1)
}
})
output$Q <- renderUI({
if (input$algo == "ARIMA")
{
numericInput("Q1",
h3("Moving Average Coeffcienct (P)"),
value = 1)
}
})
output$D <- renderUI({
if (input$algo == "ARIMA")
{
numericInput("D1",
h3("Differencing (D)"),
value = 1)
}
})
#  ARIMA(data(),input$y_variable1,input$P1,input$Q1,input$D1)
}
df = getForecastVsActual()
runApp('dashboard.R')
runApp('dashboard.R')
runApp('dashboard.R')
